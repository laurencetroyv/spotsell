import 'dart:io';

import 'package:flutter/widgets.dart';

import 'package:image_picker/image_picker.dart';

import 'package:spotsell/src/core/dependency_injection/service_locator.dart';
import 'package:spotsell/src/data/entities/products_request.dart';
import 'package:spotsell/src/data/entities/store_request.dart';
import 'package:spotsell/src/data/repositories/product_repository.dart';
import 'package:spotsell/src/ui/shared/view_model/base_view_model.dart';

class AddProductsViewModel extends BaseViewModel {
  late Store store;
  late final ProductRepository _productRepository;

  final titleController = TextEditingController();
  final descriptionController = TextEditingController();
  final priceController = TextEditingController();
  final ImagePicker picker = ImagePicker();

  Condition selectedCondition = Condition.good;
  Status selectedStatus = Status.available;
  final List<File> attachments = [];
  final List<int> selectedCategories = [];

  bool _isCreatingProduct = false;
  bool get isCreatingProduct => _isCreatingProduct;

  @override
  void initialize() {
    super.initialize();
    _productRepository = getService<ProductRepository>();
  }

  void setCondition(Condition? condition) {
    if (condition != null) {
      selectedCondition = condition;
      safeNotifyListeners();
    }
  }

  void setStatus(Status status) {
    selectedStatus = status;
    safeNotifyListeners();
  }

  Future<void> pickImage() async {
    try {
      final XFile? image = await picker.pickImage(source: ImageSource.gallery);
      if (image != null) {
        attachments.add(File(image.path));
        safeNotifyListeners();
      }
    } catch (e) {
      setError('Failed to pick image: $e');
    }
  }

  Future<void> pickImageFromCamera() async {
    try {
      final XFile? image = await picker.pickImage(source: ImageSource.camera);
      if (image != null) {
        attachments.add(File(image.path));
        safeNotifyListeners();
      }
    } catch (e) {
      setError('Failed to take photo: $e');
    }
  }

  void removeAttachment(int index) {
    if (index >= 0 && index < attachments.length) {
      attachments.removeAt(index);
      safeNotifyListeners();
    }
  }

  bool get isFormValid {
    return titleController.text.trim().isNotEmpty &&
        descriptionController.text.trim().isNotEmpty &&
        priceController.text.trim().isNotEmpty &&
        double.tryParse(priceController.text.trim()) != null;
  }

  Future<bool> createProduct() async {
    if (!isFormValid) {
      setError('Please fill in all required fields with valid data');
      return false;
    }

    _isCreatingProduct = true;
    safeNotifyListeners();

    final request = ProductsRequest(
      id: '', // Will be generated by backend
      title: titleController.text.trim(),
      description: descriptionController.text.trim(),
      price: priceController.text.trim(),
      condition: selectedCondition,
      status: selectedStatus,
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
      store: store,
      attachments: attachments.isNotEmpty ? attachments : null,
      categories: selectedCategories.isNotEmpty ? selectedCategories : null,
    );

    final success = await executeAsyncResult(
      () => _productRepository.createProduct(request),
      errorMessage: 'Failed to create product',
      showLoading: false,
      onSuccess: (product) {
        // Navigate back or show success message
        _clearForm();
        goBack();
      },
    );

    _isCreatingProduct = false;
    safeNotifyListeners();

    return success;
  }

  void _clearForm() {
    titleController.clear();
    descriptionController.clear();
    priceController.clear();
    attachments.clear();
    selectedCategories.clear();
    selectedCondition = Condition.good;
    selectedStatus = Status.available;
    clearError();
  }

  @override
  void dispose() {
    titleController.dispose();
    descriptionController.dispose();
    priceController.dispose();
    super.dispose();
  }
}
